package main

import (
	"flag"
	"google.golang.org/protobuf/compiler/protogen"
	"strings"
)

func main() {
	var flags flag.FlagSet
	protogen.Options{
		ParamFunc: flags.Set,
	}.Run(func(gen *protogen.Plugin) error {
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			generateFile(gen, f)
		}
		return nil
	})
}

func generateFile(gen *protogen.Plugin, file *protogen.File) {
	filename := file.GeneratedFilenamePrefix + "_crpc.pb.go"
	service := file.Services[0]
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-crpc. DO NOT EDIT.")
	g.P("// source: ", file.Desc.Path())
	g.P("package ", file.GoPackageName)
	g.P()
	g.P("import (")
	g.P(`    "context"`)
	g.P(`    "encoding/json"`)
	g.P(`    "fmt"`)
	g.P(`    "time"`)
	g.P()
	g.P(`    "go.mongodb.org/mongo-driver/mongo"`)
	g.P(`    "google.golang.org/grpc"`)
	g.P(")")
	g.P()
	for _, method := range service.Methods {
		g.P("type ", toLower(method.GoName), "RequestEntry struct {")
		g.P("	Timestamp time.Time            `bson:\"timestamp\"`")
		g.P("	Request   *", method.Input.GoIdent, " `bson:\"request\"`")
		g.P("}")
		g.P()
	}

	generateMongoClient(g, service)
	generateService(g, service)
	generateServer(g, service)
}

func generateMongoClient(g *protogen.GeneratedFile, service *protogen.Service) {

	g.P("type ", service.GoName, "cRPCClient interface {")
	for _, method := range service.Methods {
		g.P(method.GoName, "(ctx context.Context, in *", method.Input.GoIdent, ", opts ...grpc.CallOption) (*", method.Output.GoIdent, ", error)")
	}
	g.P("}")
	g.P("type ", toLower(service.GoName), "cRPCClient struct {")
	g.P("	client ", service.GoName, "Client")
	g.P("	db *mongo.Client")
	g.P("}")
	g.P()
	g.P("func New", service.GoName, "cRPCClient(cc grpc.ClientConnInterface, db *mongo.Client) ", service.GoName, "cRPCClient {")
	g.P("client := New", service.GoName, "Client(cc)")
	g.P("return &", toLower(service.GoName), "cRPCClient{")
	g.P("	client: client,")
	g.P("	db:		db,")
	g.P("}")
	g.P("}")
	g.P()
}

func generateService(g *protogen.GeneratedFile, service *protogen.Service) {
	for _, method := range service.Methods {
		g.P("func (s *", toLower(service.GoName), "cRPCClient", ") ", method.GoName, "(ctx context.Context, req *", method.Input.GoIdent, ", opts ...grpc.CallOption) (*", method.Output.GoIdent, ", error) {")
		g.P(`    // Log the request to MongoDB async`)
		g.P(`    go s.db.Database("`, service.GoName, `").Collection("`, method.GoName, `").InsertOne(ctx, &`, toLower(method.GoName), `RequestEntry {`)
		g.P(`		Timestamp: time.Now(),`)
		g.P(`		Request:   req,`)
		g.P(`	})`)
		g.P()
		g.P(`    // Invoke the original RPC method`)
		g.P(`    resp, err := s.client.`, method.GoName, "(ctx, req)")
		g.P()
		g.P(`    // Handle response and error`)
		g.P(`    if err != nil {`)
		g.P(`        return nil, err`)
		g.P(`    }`)
		g.P(`    return resp, nil`)
		g.P("}")
		g.P()
	}
}

func generateServer(g *protogen.GeneratedFile, service *protogen.Service) {
	g.P(`func readFlags(c *CRPCConfig) {`)
	g.P(`	for {`)
	g.P(`		response, err := http.Get(fmt.Sprintf("http://%s/api/flags?service_name=%s&is_staging=%t", c.ControlPlaneURL, c.ServiceName, c.IsStaging))`)
	g.P(`		if err != nil {`)
	g.P(`			fmt.Println(err)`)
	g.P(`			time.Sleep(10 * time.Second)`)
	g.P(`			continue`)
	g.P(`		}`)
	g.P(`		decoder := json.NewDecoder(response.Body)`)
	g.P(`		err = decoder.Decode(&c.FlagData)`)
	g.P(`		if err != nil {`)
	g.P(`			time.Sleep(10 * time.Second)`)
	g.P(`			continue`)
	g.P(`		}`)
	g.P(`		fmt.Println(c.FlagData)`)
	g.P(`		time.Sleep(10 * time.Second)`)
	g.P(`	}`)
	g.P(`}`)
	g.P(``)
	g.P(`func  Register`, service.GoName, `CRPCServer(s grpc.ServiceRegistrar, srv `, service.GoName, `Server, c *CRPCConfig) {`)
	g.P(`	go readFlags(c)`)
	g.P(`	s.RegisterService(&`, service.GoName, `_ServiceDesc, srv)`)
	g.P(`}`)
}

func toLower(s string) string { return strings.ToLower(s[:1]) + s[1:] }
