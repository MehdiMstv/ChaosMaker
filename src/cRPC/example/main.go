// Code generated by protoc-gen-chaos-maker.
// source: example/interface/calculator.proto
package main

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"time"

	"github.com/gin-gonic/gin"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
	"google.golang.org/grpc/status"

	"github.com/MehdiMstv/ChaosMaker/src/cRPC/example/interface/calculator"
)

type config struct {
	LoggerMongodbURI string
	ControlPlaneURL  string
	StagingAddress   string `json:"staging_address"`
	ServiceName      string
	Port             string
}

type calculateRequestEntry struct {
	Timestamp primitive.DateTime           `bson:"timestamp"`
	Request   *calculator.CalculateRequest `bson:"request"`
}

type getRandomRequestEntry struct {
	Timestamp primitive.DateTime           `bson:"timestamp"`
	Request   *calculator.GetRandomRequest `bson:"request"`
}

func RunServer(db *mongo.Client, conn *grpc.ClientConn, c *config) {
	router := gin.Default()
	router.POST("/start_Calculate_chaos", handleCalculateChaos(db, conn, c))
	router.POST("/start_GetRandom_chaos", handleGetRandomChaos(db, conn, c))
	router.GET("/methods", getMethods)
	err := router.Run(":" + c.Port)
	if err != nil {
		return
	}
}

func getRequests(db *mongo.Client, methodName string) (*mongo.Cursor, error) {
	requests, err := db.Database("Calculator").Collection(methodName).Find(context.Background(), bson.D{})
	if err != nil {
		return nil, err
	}
	return requests, nil
}

func handleCalculateChaos(db *mongo.Client, conn *grpc.ClientConn, config *config) gin.HandlerFunc {
	fn := func(c *gin.Context) {
		chaosID := c.Request.FormValue("id")
		var data []calculateRequestEntry

		http.Post(fmt.Sprintf("http://%s/api/chaos?id=%s", config.ControlPlaneURL, chaosID), "application/json", nil)

		filters, _ := getRequests(db, "Calculate")
		err := filters.All(context.Background(), &data)
		if err != nil {
			c.JSON(500, gin.H{"error": err.Error()})
			return
		}

		client := calculator.NewCalculatorClient(conn)
		http.Post(fmt.Sprintf("http://%s/api/chaos?id=%s", config.ControlPlaneURL, chaosID), "application/json", nil)

		resultData := make(map[string]int)
		for _, v := range data {
			_, err := client.Calculate(context.Background(), v.Request)
			if err != nil {
				if s, ok := status.FromError(err); ok {
					resultData[s.Code().String()] = resultData[s.Code().String()] + 1
				} else {
					resultData["Unknown"] = resultData["Unknown"] + 1
				}
				continue
			}
			resultData["Success"] = resultData["Success"] + 1
		}

		jsonString, _ := json.Marshal(resultData)
		http.Post(fmt.Sprintf("http://%s/api/chaos?id=%s", config.ControlPlaneURL, chaosID), "application/json", bytes.NewBuffer(jsonString))
		c.String(http.StatusOK, "Chaos Done")
	}

	return fn
}

func handleGetRandomChaos(db *mongo.Client, conn *grpc.ClientConn, config *config) gin.HandlerFunc {
	fn := func(c *gin.Context) {
		chaosID := c.Request.FormValue("id")
		var data []getRandomRequestEntry

		http.Post(fmt.Sprintf("http://%s/api/chaos?id=%s", config.ControlPlaneURL, chaosID), "application/json", nil)

		filters, _ := getRequests(db, "GetRandom")
		err := filters.All(context.Background(), &data)
		if err != nil {
			c.JSON(500, gin.H{"error": err.Error()})
			return
		}

		client := calculator.NewCalculatorClient(conn)
		http.Post(fmt.Sprintf("http://%s/api/chaos?id=%s", config.ControlPlaneURL, chaosID), "application/json", nil)

		resultData := make(map[string]int)
		for _, v := range data {
			ctx, cancel := context.WithTimeout(context.Background(), time.Second*2)
			defer cancel()
			_, err := client.GetRandom(ctx, v.Request)
			fmt.Println(err)
			if err != nil {
				if s, ok := status.FromError(err); ok {
					resultData[s.Code().String()] = resultData[s.Code().String()] + 1
				} else {
					resultData["Unknown"] = resultData["Unknown"] + 1
				}
				continue
			}
			resultData["Success"] = resultData["Success"] + 1
		}

		jsonString, _ := json.Marshal(resultData)
		http.Post(fmt.Sprintf("http://%s/api/chaos?id=%s", config.ControlPlaneURL, chaosID), "application/json", bytes.NewBuffer(jsonString))
		c.String(http.StatusOK, "Chaos Done")
	}

	return fn
}

func getMethods(c *gin.Context) {
	var methods []string
	methods = append(methods, "Calculate")
	methods = append(methods, "GetRandom")
	c.JSON(200, gin.H{"methods": methods})
}

func getStagingAddress(c *config) error {
	response, err := http.Get(fmt.Sprintf("http://%s/api/service/staging_address?name=%s", c.ControlPlaneURL, c.ServiceName))
	if err != nil {
		return err
	}
	if response.StatusCode != 200 {
		return fmt.Errorf("failed to get staging address")
	}

	body, err := io.ReadAll(response.Body)
	if err != nil {
		return err
	}

	err = json.Unmarshal(body, &c)
	if err != nil {
		return err
	}

	return nil
}

// main function of program, you can change config values here
func main() {
	c := &config{
		LoggerMongodbURI: "mongodb://127.0.0.1:27017/",
		ControlPlaneURL:  "127.0.0.1:9033",
		ServiceName:      "Calculator",
		Port:             "8082",
	}

	err := getStagingAddress(c)
	if err != nil {
		log.Fatal(err)
		return
	}

	mongoClient, err := mongo.Connect(context.Background(), options.Client().ApplyURI(c.LoggerMongodbURI))
	if err != nil {
		log.Fatal(err)
		return
	}

	conn, err := grpc.Dial(c.StagingAddress, grpc.WithTransportCredentials(insecure.NewCredentials()))
	if err != nil {
		log.Fatal(err)
		return
	}

	RunServer(mongoClient, conn, c)
}
